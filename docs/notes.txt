***1 TO 3***

* New Project: `cargo new project-name`
* run: cargo run
* add dependencies: cargo add depname
* install dependency: cargo build
* import: use depName::funcName;
* main se sentry

* COMMENTS: 
    - // OR /* here */

* MACROS are different than functions and identify by ! after name.
    - can generate more complex code at compile time
    - provide additional functionality over regular functions.
    - println! macro allows for formatted strings and variadic arguments (a variable number of arguments).
* Formatting: println! is not just for printing plain text; it can also format strings. For example, println!("Hello, {}!", "world"); would replace {} with world.


* CRATES.io, the package registry for Rust. In Rust, we often refer to packages as “crates.”
* x::y signifies y is an associated function of x
* VERSIONING
    [dependencies]
    rand = "0.8.5"
    // this means ^0.8.5 but below 0.9.0



* vars and even references are immutable by default
    let x = 5; //immutable
    let mut y =3; //mutable
* new strings
    let mut x = String::new();
* error handler
    .expect("err message here")
* snake case as the conventional style (this_is_called_snake_case)


* INPUT 
    using read_line take the value 
    and returns an enum result, 
    ie of `Ok` or `Err`,
    if err then .expect called


* MATCH:
    `
        match var1.cmp(&var2) {
            Ordering::Less => println("too small!"),
            ...
        }
    `
    - Ordering is an enum of types `Less`, `Greater`, `Equal`


- no implicit type conversion,


* SHADOWING, use same name of var for type conversion, more later


* LOOPS
    - literally just write loop{/*codehere*/}
    - use break to break lol
    - can return value from loop using break 
    `   let mut counter = 0;
        let result = loop {
            counter += 1;
            if counter == 10 {
                break counter * 2;
            }
        } `
    - break exits current loop, return exits current function
    - continue exists
    - loop label: begin with a '
        'counting_up: loop {}
    - for NESTED, to break out of upper loop not current specify name
        break 'counting_up;

- _ as an arg is for catching any value


* INT OVERFLOW
    - compiling in release mode with the --release flag, removes checks for overflow
    - Handling overflow explicitly
        1. Wrapping Methods: 
            Example in Rust: wrapping_add, wrapping_sub, wrapping_mul, etc.
            If max value exceeded wraps to minimum value
            `
                let x: u8 = 255;
                let y = x.wrapping_add(1); // y will be 0
            `
        2. Checked Methods:
            Example in Rust: checked_add, checked_sub, checked_mul, etc.
            If max value exceeded, returns `None` else `Some(result)`
            `
                let x: u8 = 255;
                let y = x.checked_add(1); // y will be None because it overflows
            `
        3. Overflowing Methods:
            Example in Rust: overflowing_add, overflowing_sub, overflowing_mul, etc.
            Returns tuple of result of operation and if overflow occurred
            `
                let x: u8 = 255;
                let (result, overflowed) = x.overflowing_add(1); // result will be 0, overflowed will be true
            `
        4. Saturating Methods:
            Example in Rust: saturating_add, saturating_sub, saturating_mul, etc.
            If overflowor underflow occurs, result is stopped at the max or min value respectively
            `
                let x: u8 = 255;
                let y = x.saturating_add(1); // y will be 255 (maximum value for u8)
            `


* NUMERIC OPERATORS
    + - * / %
    - let truncated = -5 / 3; // Results in -1


- char literals: single qoutes ''
- string literals: double qoutes ""


* SIZES
        Length	Signed	Unsigned
    INTEGERS 
        8-bit	i8	    u8
        16-bit	i16	    u16
        32-bit	i32	    u32
        64-bit	i64	    u64
        128-bit	i128	u128
        arch	isize	usize
    FLOATS (signed)
        32-bit  f32 (single pres)
        64-bit  f64 (double pres, default)
    BOOLEAN
        8-bit   bool
    CHAR
        32-bit  char

* COMPOUND types
    - TUPLE (tup)
        fixed length once declared
        a comma-separated list of values inside parentheses
        the types of the different values in the tuple don’t have to be the same
        Declare:   `   let tup: (i32, f64, u8) = (500, 6.4, 1);    `
        Use:     
            Destructuring   `   let tup = (500, 6.4, 1);
                                let (x, y, z) = tup;
                                println!("The value of y is: {y}");
                            `
            Period  `   
                        let x: (i32, f64, u8) = (500, 6.4, 1);
                        let five_hundred = x.0;
                        let six_point_four = x.1;
                        let one = x.2;
                    `
        Tuples w/o value -> unit
    - ARRAY ([types; index])
        fixed length
        Declare:    `   let a: [i32; 5] = [1, 2, 3, 4, 5];    `
                    `   let a = [3; 5]; //gives 3,3,3,3,3     `
        Use:
            `
                let first = a[0];
                let second = a[1];
            `
        If you try to access out of bounds index, prog will panic //RUNTIME


GOOD SHIT
 Rust is an ahead-of-time compiled language, meaning you can compile a program and give the executable to someone else, and they can run it even without having Rust installed.
 Pust has preset items called prelude, in https://doc.rust-lang.org/std/prelude/index.html



* FUNCTIONS
    - not like c, CAN define functions upar or neeche
    - calling SAME as c
    - params SAME as c but for type 
        YES => `x: i32`
        NO =>   `i32 x`
    - RETURN: 
        type after an arrow `fn func_name() -> ret_type{//code here}`
        no return keyword just an expression (given below)
        fn five() -> i32 {
            5 //aisa lonely sa without semicolon is the return
        }

* STATEMENTS
    - instructions that perform some action
    - do NOT return a value.
    - let, function definitions, 
    - WRONG :` fn main() {
                    let x = (let y = 6);
                } `

* EXPRESSIONS
    - evaluate to a value
    - RIGHT:`let y = {
                    let x = 3;
                    x + 1 //NOTE NO SEMICOLON HERE
                }; `
    - cant have semicolon at end warna become statements



* CONDITIONALS
    - if
        no parentheses
        `
            if number < 5 {
                println!("condition was true");
            } else if number>3{
               println!("condition was true2"); 
            } else {
                println!("condition was false");
            }
        ` 
        NO: if number 
        (not like js, that 5 is true and 0 is false, do it explicitly)
        VALID: let number2 = if condition { 5 } else { 6 };//assigns 5 if true
        INVALID: let number2 = if condition { 5 } else { "hi" };/
                   COMPILE ERR //gives expected int cause 1st expression is int
    - while
        `while cond==ition {code}`
    - for
        `for element in a{code here}` //given a is an array
        `for number in (1..4) {}` executres 1 2 3 NOT 4


* LOGICAL OPERATORS:
    && || != !

- .rev() is a function that reverses
    so on a range (1..4).rev() gives 321



*** 4 ***

* OWNERSHIP
    - memory safety guarantees without needing a garbage collector
    - there are set of rules which compiler checks
        if rule not followed, no compilation
    - stack heap, same concepts, stack is faster to store and access
    - main purpose of ownership is to manage heap data

* OWNERSHIP RULES
    - Each value in Rust has an owner.
    - There can only be one owner at a time.
    - When the owner goes out of scope, the value will be dropped.
    
- scope, same
- String be mutated but literals cannot

* MEMORY and ALLOC
    - string literals, get memory allocated to them suring compile time
    - can do the same with a mutable string, we need"
        memory at run time, String::from
        return memory when done
    -  the memory is automatically returned once the variable that owns it goes out of scope
    - Rust calls drop automatically at the closing curly brack
* MOVE
    - you cant assign one string to another, like let s1 = s2; is a nope
    - string have ptr, len and capacity, so ptr points same place when you assign
    - causes DOUBLE FREE error, both s1 and s2 try to drop 
    - so after s2 = s1, s1 is considered invalid
    - any automatic copying can be assumed to be inexpensive in terms of runtime performance
    cause auto drop of s1

* CLONE
    - used to create a copy, not just same pointing
    -       let s1 = String::from("hello");
            let s2 = s1.clone();
            println!("s1 = {s1}, s2 = {s2}");
        gives: s1 = hello, s2 = hello;

* COPY
    - this is what happens with int, or like wth clone
    - bool, ints, float char can use

* FUNCTIONS AND OWNERSHIP
    - if i pass a string as an arg to a function, it is NO LONGER VALID
    - let s = String::from("hello");  // s comes into scope
        takes_ownership(s);             
    - so if  let s = func_name();//return on func moves into s
    - SOLUTION: reference, similar to c
    - eg:  let len = calculate_length(&s1);
      can still use s1 after this
      so now the str in function is basically a pointer to s1 ka pointer
* BORROWING:
    - action of creating a reference
    - cant modify it while borrowing
* MUTABLE REFERENCE: 
    - pass &mut s
        let s2 = functi_name(&mut s1);
    - can only have ONE mutable reference to a perticular value
    - TWO will FAIL
    - prevents data races (race condition)
    - Happens when:
        Two or more pointers access the same data at the same time.
        At least one of the pointers is being used to write to the data.
        There’s no mechanism being used to synchronize access to the data.
    - Below gives cannot borrow `s` as mutable because it is also borrowed as immutable
        let r2 = &s; // no problem
        let r3 = &mut s; // BIG PROBLEM
    - can do above only if scopes don’t overlap
* DANGLING REFERENCES/ POINTERS
    - when pointer points to adress which has already been free/ dropped
    - rust ENSURES this wont happen gives COMPILATION ERROR

NOTE: can return multiple from func using tuples


* SLICE
    - if we find index of soething in strig, string might drop but the int of index remains ie bad
    - let hello = &s[0..5];
    - let hello = &s[..5]; //same as above
    - let hello = &s[..]; //means entire string
    - can do this on arr of other types too



* STRUCTS (similar to c structs)
    - custom data type
    - struct Name_here {
        active: bool,
        username: String,
        sign_in_count: u64, //hash im guessing
    }
    - define as:
        let user1 = Name_here {
            active: true, ...
        };
    - to access:
        user1.email = ...
    - either all fields mutable or all immutable, cant mix match
    - can use a function to returen new istance of the struct,
        pass values at arguments
        (kinda like a constructor lol)
    - use String and not &str, cause we want instance to own data
    - structs can NOT be println directly with {varname} 
* field init shorthand syntax
    - passed arg and struct field name same so just using once
    - like in this.user = user is same as just user,
* TUPLE STRUCTS
    - same as tuples... but tuple cn have a name
    -  struct Color(i32, i32, i32);
        struct Point(i32, i32, i32);
        fn main() {let black = Color(0, 0, 0);
        let origin = Point(0, 0, 0);}
    -  cant assigna point to a color now, safer
* unit-like structs
    - struct AlwaysEqual;
        fn main() {
            let subject = AlwaysEqual;
        }
    - when we want a trait but no data as such


* PRINTLN formats
    - println macro can use different formats to o/p
    - default is Display (cant print struct)
    - Debug o/p format:
        We have to manually add opt to each type we want to use debug on
        #[derive(Debug)] //add this right before struct defination
        println!("rect1 is {rect1:?}");//tells compiler we wanna use "Debug" o/p format
        :? prettu print in one line, 
        :#? pretty print over few lines
* dbg! macro (using debug too)
    - dbg!(&rect1); 
    - takes ownership not reference
    - prints file and line number
    - returns ownership of the value